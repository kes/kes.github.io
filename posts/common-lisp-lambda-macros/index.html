<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
    <title>Common Lisp Lambdas and Macros :: </title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="I was thinking about lambdas and closures the other day (&amp;lsquo;cause after all, why not?), and I was looking at Paul Graham&amp;rsquo;s excellent ANSI Common Lisp &amp;ndash; in chapter one he begins by asking, &amp;ldquo;why learn Lisp?&amp;rdquo; And he shows some C and Lisp code for summing the integers less than n, like so:
int sum (int n){ int i, s = 0; for (i=0; i&amp;lt; n; i&#43;&#43;) s &#43;= i; return s; } And, then Common Lisp:" />
<meta name="keywords" content="" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="http://localhost:1313/posts/common-lisp-lambda-macros/" />





  
  <link rel="stylesheet" href="http://localhost:1313/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/code.min.d529ea4b2fb8d34328d7d31afc5466d5f7bc2f0bc9abdd98b69385335d7baee4.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/main.min.36833afd348409fc6c3d09d0897c5833d9d5bf1ff31f5e60ea3ee42ce2b1268c.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="http://localhost:1313/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">




<link rel="stylesheet" href="http://localhost:1313/style.css">


<link rel="shortcut icon" href="http://localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Common Lisp Lambdas and Macros">
<meta property="og:description" content="I was thinking about lambdas and closures the other day (&amp;lsquo;cause after all, why not?), and I was looking at Paul Graham&amp;rsquo;s excellent ANSI Common Lisp &amp;ndash; in chapter one he begins by asking, &amp;ldquo;why learn Lisp?&amp;rdquo; And he shows some C and Lisp code for summing the integers less than n, like so:
int sum (int n){ int i, s = 0; for (i=0; i&amp;lt; n; i&#43;&#43;) s &#43;= i; return s; } And, then Common Lisp:" />
<meta property="og:url" content="http://localhost:1313/posts/common-lisp-lambda-macros/" />
<meta property="og:site_name" content="" />

  <meta property="og:image" content="http://localhost:1313/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-11-12 00:00:00 &#43;0000 UTC" />












  
  <script src="http://localhost:1313/js/mathjax-config.js"></script>

  
  <script
    id="MathJax-script"
    async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>




</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Karl Stump
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about/about/">About</a></li>
        
      
        
          <li><a href="/leetcode/">Leet Code</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about/about/" >About</a></li>
        
      
        
          <li><a href="/leetcode/" >Leet Code</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="http://localhost:1313/posts/common-lisp-lambda-macros/">Common Lisp Lambdas and Macros</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-11-12</time><span class="post-author">[Karl Stump]</span></div>

  
    <span class="post-tags">
      
      #<a href="http://localhost:1313/tags/lisp/">lisp</a>&nbsp;
      
      #<a href="http://localhost:1313/tags/java/">java</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <p>I was thinking about lambdas and closures the other day (&lsquo;cause after all, why not?), and I was looking at Paul Graham&rsquo;s excellent <a href="https://www.google.com/search?q=ansi%20common%20lisp%20book&sclient=gws-wiz">ANSI Common Lisp</a> &ndash; in chapter one he begins by asking, &ldquo;why learn Lisp?&rdquo; And he shows some <code>C</code> and <code>Lisp</code> code for summing the integers less than <code>n</code>, like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">sum</span> (<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> i, s <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    s <span style="color:#f92672">+=</span> i;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> s;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And, then <code>Common Lisp</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun sum (n)
</span></span><span style="display:flex;"><span>  (<span style="color:#66d9ef">let</span> ((s <span style="color:#ae81ff">0</span>))
</span></span><span style="display:flex;"><span>    (dotimes (i n s)
</span></span><span style="display:flex;"><span>      (incf s i))))
</span></span></code></pre></div><p>And he makes the interesting statement:</p>
<blockquote>
<p>If you only need to do such simple things, it doesn&rsquo;t really matter which language you use.</p>
</blockquote>
<p>And that&rsquo;s a great observation.</p>
<p>There may be any number of reasons for choosing one language over another. Everything from the number of available developers to code in the language, to the speed of the resulting executable code. Among various reasons, is also the important question, &ldquo;what can I do with it?&rdquo;</p>
<p>The two features of Lisp that made it unique were closures and macros. Add in strong run-time typing, Graham could write eloquently:</p>
<blockquote>
<p>With macros, closures, and run-time typing, Lisp transcends object oriented programming.</p>
</blockquote>
<p>Graham&rsquo;s book was published in 1996 and he believed that the features of <code>Lisp</code> would bring a new way of programming. Indeed, it was one of his goals for his book was to explain this new approach:</p>
<blockquote>
<p>One of the aims of this book is to explain not just the Lisp language, but the new approach to programming that Lisp makes possible. This approach is one that you will see more of in the future.</p>
</blockquote>
<p>As noble as his sentiment was, and is, and whatever the benefits of <code>Lisp</code> for programming, it is still nevertheless a fact that <code>Lisp</code> never caught on.</p>
<h2 id="lambda">Lambda<a href="#lambda" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Graham demonstrates a lexical closure in <code>Lisp</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun addn (n)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">#&#39;</span>(lambda (x)
</span></span><span style="display:flex;"><span>    (<span style="color:#a6e22e">+</span> x n)))
</span></span></code></pre></div><p>This type of thing, the lambda, and further a closure, really is the bread-and-butter of <code>Lisp</code> programming. The fact that many programmers do know about them, much less, feel a need for them ties into one of Graham&rsquo;s themes: &ldquo;programming languages teach you not to want what they cannot provide.&rdquo;</p>
<p>Lambdas have been in Lisp since 1959.</p>
<p>Java introduced lambda expressions in version 8 (2014).</p>
<p>And here is Oracle&rsquo;s page on  <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Lambda Expressions</a>.</p>
<p>But <a href="https://kes.github.io/posts/whatisalambda/">what is a lambda</a>. Quite simply it&rsquo;s an anonymous function.</p>
<p>At the time, there was a lot of excitement. But, now, maybe the lambda in Java was not all that it was cracked up to be??</p>
<p>According to some lambdas have died: <a href="https://medium.com/@kotiavula6/rip-java-lambdas-2014-2025-you-were-cool-until-you-werent-4ab9bac644c8">RIP Java Lambdas</a>, and according to that post the reasons are:</p>
<ol>
<li>Debugging hell</li>
<li>Unreadable for Junior Devs</li>
<li>Harder to Unit Test</li>
<li>Performance Hit</li>
<li>False Promise of Functional Purity</li>
</ol>
<p>Definitely worth a look.</p>
<p>The problem is, IMO (you do notice the IMO, right?), the problem is that lambdas don&rsquo;t really belong in Java. That might be a controversial opinion. But really, lambdas are simply not where the soul of Java is found. This is not to say that the syntactic sugar for an anonymous class in Java is not a nice thing. It totally is. I love it, and I use it.</p>
<p>It should be noted that lambdas and closure are not the same thing. A lambda is an anonymous function. A closure, on the other hand, is a function that captures and retains access to variables from its lexical scope &ndash; even when executed outside that scope. See <a href="https://calledges.com/computer/closure-vs-lambda">Closure vs Lambda</a></p>
<p>In Lisp the lambda <em>is</em> a closure. And in Java it&rsquo;s not. And that&rsquo;s okay. In fact, lambda might not even be the strongest paradigm in <code>Lisp</code>.</p>
<p>In Java, if you want to define a Lambda, you&rsquo;ll start with an Interface:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#a6e22e">@FunctionalInterface</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Operation</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">operate</span>(<span style="color:#66d9ef">int</span> n);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And somewhere along the line, you will have to implement the interface. (No, you are not instantiating the Interface. That cannot be done. You must implement interfaces.) For example,</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Lambda</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String args<span style="color:#f92672">[]</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 12;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> 88;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        temp(a, <span style="color:#66d9ef">new</span> Operation() {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// overrides the operate() method</span>
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">operate</span>(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>                    <span style="color:#75715e">// prints the result</span>
</span></span><span style="display:flex;"><span>                    System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Result is: &#34;</span> <span style="color:#f92672">+</span> (n <span style="color:#f92672">+</span> b));
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">temp</span>(<span style="color:#66d9ef">int</span> i, Operation op) {
</span></span><span style="display:flex;"><span>        op.<span style="color:#a6e22e">operate</span>(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Of course, this is all very ugly. I mean it is an anonymous class with the interfaces method, so that&rsquo;s good and useful. But there is better syntactic sugar available.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> 12;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> b <span style="color:#f92672">=</span> 88;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// overrides the operate() method</span>
</span></span><span style="display:flex;"><span>temp(a, n <span style="color:#f92672">-&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// prints the result</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Result is: &#34;</span> <span style="color:#f92672">+</span> (n <span style="color:#f92672">+</span> b));
</span></span><span style="display:flex;"><span>    });
</span></span></code></pre></div><p>And boom! That strange and scary <code>-&gt;</code> &ndash; behold, lambda! Neat, and readable.</p>
<p>It&rsquo;s a lambda. But is it a closure? Typically a closure is defined as a lambda enclosing over a local variable in the scope of the defined lambda. In this example, the local <code>b</code> is in the scope of the lambda. But there&rsquo;s only so much that you can do with it.</p>
<p>So, in my opinion, Java does have closures. The use of the local variable <code>b</code> in the method is very much limited. It cannot be modified. And while there might be any number of technical reasons why this is so, all well and good, but the point is that <code>b</code> cannot be modified. In my view a closure must allow the enclosed local variables to be modified. Perhaps I&rsquo;m wrong?</p>
<p>In any event, in <code>Lisp</code> this is easily done:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun adjust (meter)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">#&#39;</span>(lambda (x)
</span></span><span style="display:flex;"><span>      (<span style="color:#66d9ef">setq</span> meter (<span style="color:#a6e22e">+</span> x meter))))
</span></span></code></pre></div><p>Here the lambda has closed over the local meter, and meter is fully usable. This would also be true for any variables defined with <code>let</code>, and hence a closure in <code>Lisp</code> is sometimes called a, &ldquo;let over a lambda&rdquo;</p>
<p>Or we could have:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defun meter-maker (meter)
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">#&#39;</span>(lambda(x <span style="color:#66d9ef">&amp;optional</span> parm)
</span></span><span style="display:flex;"><span>      (cond ((<span style="color:#a6e22e">eq</span> x <span style="color:#e6db74">:incr</span>) (<span style="color:#66d9ef">setq</span> meter (<span style="color:#a6e22e">+</span> meter parm)))
</span></span><span style="display:flex;"><span>            ((<span style="color:#a6e22e">eq</span> x <span style="color:#e6db74">:decr</span>) (<span style="color:#66d9ef">setq</span> meter (<span style="color:#a6e22e">-</span> meter parm)))
</span></span><span style="display:flex;"><span>            ((<span style="color:#a6e22e">eq</span> x <span style="color:#e6db74">:get</span>) meter)
</span></span><span style="display:flex;"><span>            (<span style="color:#66d9ef">t</span> <span style="color:#e6db74">&#34;command unrecognized&#34;</span>))))
</span></span></code></pre></div><p>That&rsquo;s all good. But again, here&rsquo;s a secret: lambda and closures, while very strong, are the not the strongest feature of <code>Lisp</code>. The real power of <code>Lisp</code> is in its macros.</p>
<h2 id="macros">Macros<a href="#macros" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>The really key strength of <code>Lisp</code> is found in what most coders dislike most on encountering <code>Lisp</code> and that is parentheses. Well, not parentheses exactly but something called <a href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconicity</a>. Because of this property, in <code>Lisp</code> the developer can write programs that write programs, using a rather unique feature in <code>Lisp</code> called <code>macros</code>.</p>
<blockquote>
<p>Macros are the single greatest advantage that lisp has as a programming language and the single greatest advantage of any programming language. With them you can do things that you simply cannot do in other languages. (Doug Hoyte, <a href="https://letoverlambda.com/index.cl">Let Over Lambda</a>)</p>
</blockquote>
<p>Note: This is simply touching upon the topic of macros, not a deep dive. Someday, I&rsquo;ll &hellip;</p>
<p>Unfortunately, when the word &ldquo;macro&rdquo; is used most will think of a sort of basic substitution.</p>
<blockquote>
<p>I can&rsquo;t emphasize enough that the Common Lisp macro shares essentially nothing but the name with the text-based macros found in C and C++. Where the C pre-processor operates by textual substitution and understands almost nothing of the structure of C and C++, a Lisp macro is essentially a code generator that gets run for you automatically by the compiler. (Peter Seibel, <a href="https://gigamonkeys.com/book/">Practical Common Lisp</a>)</p>
</blockquote>
<p>In <code>Lisp</code> the macro facility has the full power of the <code>Lisp</code> language. You are able to control, using the power of <code>Lisp</code>, what the compiler sees, and so, the macro, is the defining of a new language, or a DSL, or simply making language additions. These additions can greatly aid in writing code, understanding code, and in abstracting away boilerplate. It is, or should be, a programmer&rsquo;s dream.</p>
<p>So powerful are Lisp macros that it is usual considered an advanced feature, to be introduced after the language has been thoroughly covered. Peter Seible takes a different view and in his book, <a href="https://gigamonkeys.com/book/">Practical Common Lisp</a>, introduces macros in chapter three. Only four chapters later, Seibel devotes three chapters to macros: <a href="https://gigamonkeys.com/book/macros-standard-control-constructs">7.Macros: Standard Control Constructs</a>, <a href="https://gigamonkeys.com/book/macros-defining-your-own">8.Macros: Defining Your Own</a>, <a href="https://gigamonkeys.com/book/practical-building-a-unit-test-framework">9.Practical: Building a Unit Test Framework</a></p>
<p>And I could be wrong, but the &ldquo;enlightenment&rdquo; that is often spoken about when learning <code>Lisp</code> is I think found here in the idea of &ldquo;code that writes code.&rdquo; I could be wrong.</p>
<blockquote>
<p>The most common way to write programs that write programs is by defining macros. Macros are operators that are implemented by transformation. You define a macro by saying how a call to it should be translated. This translation, called macro-expansion, is done automatically by the compiler. So the code generated by your macros becomes an integral part of your program, just as if you had typed it in yourself.</p>
</blockquote>
<p>A simple example is given as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defmacro nil! (x)
</span></span><span style="display:flex;"><span>  (<span style="color:#a6e22e">list</span> <span style="color:#e6db74">&#39;setf</span> x <span style="color:#66d9ef">nil</span>))
</span></span></code></pre></div><p>We can use <code>macroexpand</code> to see what the result is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(<span style="color:#a6e22e">macroexpand-1</span> <span style="color:#f92672">&#39;</span>(nil! a))
</span></span></code></pre></div><p>Which gives the expected <code>(SETF A NIL)</code> because that&rsquo;s the code that the macro creates.</p>
<p>You can see that the parameter &ldquo;x&rdquo; was assigned the value &ldquo;a&rdquo; and so the list generated (as already given) is <code>(SETF A NIL)</code>. This list is code that can be (will be) expanded during compilation and executed at runtime.</p>
<p>The significance of this should not be missed. It is of course equivalent to &ldquo;hello world,&rdquo; and so, it might be easy to say, &ldquo;so what?&rdquo; It should be noted that we have just modified the <code>Lisp</code> language. This is code that creates code, and that created code will be compiled and executed.</p>
<p>So, a macro is <code>Lisp</code> code that produces <code>Lisp</code> code. And the macro &ldquo;language&rdquo; is not in any way less than any other <code>Lisp</code> code. It is <code>Lisp</code> code. A <code>Lisp</code> macro is not some &ldquo;lisp lite,&rdquo; but instead, <code>Lisp</code> macros have the full power of the <code>Lisp</code> compiler.  This macro facility, therefore, is rather unique.  (I am not familiar with all programming languages in the world, so I say, &ldquo;rather unique.&rdquo;)</p>
<p>My understanding: Java uses annotation processors and code generation tools to simulate some macro-like behavior, but it does not support true macros, and certainly nothing approaching <code>Lisp</code> macros. Thus, while annotations can simplify code and reduce boilerplate, they do not offer the same level of flexibility.</p>
<p>Ideally a macro is defined using <code>backtick</code> rather than <code>list</code> (above) &ndash; and within the <code>backtick</code> list a comma for evaluation. Like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(defmacro nil! (x)
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">`</span>(setf <span style="color:#f92672">,</span>x <span style="color:#66d9ef">nil</span> ))
</span></span></code></pre></div><p>Thus, <code>backtick</code> allows for evaluation. <code>,x</code> means that x is to be evaluated and the result substituted. Other than this syntax difference, the macros are effectively the same, producing the same code.</p>
<p>However, it can be imagined since <del>creating lists</del> <strong>creating code</strong> is the whole point of a macro, then there would be various kinds of evaluation and substitution.</p>
<p>So, consider the following distinction between <code>,</code> and <code>,@</code>, that latter of which is called &ldquo;splicing.&rdquo;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>CL-USER&gt; (setf lst <span style="color:#f92672">&#39;</span>(a b c))
</span></span><span style="display:flex;"><span>(A B C)
</span></span><span style="display:flex;"><span>CL-USER&gt; <span style="color:#f92672">`</span>(<span style="color:#a6e22e">list</span> is <span style="color:#f92672">,</span>lst)
</span></span><span style="display:flex;"><span>(LIST IS (A B C))
</span></span><span style="display:flex;"><span>CL-USER&gt; <span style="color:#f92672">`</span>(<span style="color:#a6e22e">list</span> has these elements <span style="color:#f92672">,@</span>lst)
</span></span><span style="display:flex;"><span>(LIST HAS THESE ELEMENTS A B C)
</span></span></code></pre></div><p>That&rsquo;s enough for now. Graham&rsquo;s hope that <code>Lisp</code> would bring in a new wave of programming was not fulfilled. Too bad for a generation of programmers.</p>
<blockquote>
<p>Meanwhile, ideas borrowed from Lisp increasingly turn up in the mainstream: interactive programming environments, garbage collection, and run-time typing, to name a few.</p>
</blockquote>
<p><a href="https://common-lisp.net/">Common-Lisp.net</a></p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">Read other posts</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="http://localhost:1313/posts/learning-never-stops/" class="button inline prev">
        &lt; [<span class="button__text">Learning Never Stop</span>]
      </a>
    
    
      ::
    
    
      <a href="http://localhost:1313/posts/programming-with-chatgpt/" class="button inline next">
         [<span class="button__text">C Programming with ChatGPT</span>] &gt;
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
